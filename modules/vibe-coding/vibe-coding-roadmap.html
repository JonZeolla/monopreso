<section data-transition="none">
  <h2>AI Coding Design Patterns</h2>
  <ol>
    <li class="fragment fade-in-then-semi-out">
      Use version control (i.e. <code>git</code>) and linters
    </li>
    <li class="fragment fade-in-then-semi-out">
      Ensure good unit / integration / e2e test coverage. Use LLMs to add coverage quickly
    </li>
    <li class="fragment fade-in-then-semi-out">
      Distribute common LLM instructions (sometimes called rules) and store them in your repositories
    </li>
    <li class="fragment fade-in-then-semi-out">
      Put automated Pull Request reviews in place
    </li>
    <li class="fragment fade-in-then-semi-out">
      Optimize for iteration; make it easier to make, approve, and test frequent, small changes to requirements
    </li>
  </ol>
  <aside class="notes">
    For rules: use what you currently have - engineer onboarding, policies, etc. to inform the instructions
  </aside>
</section>
<section data-transition="none">
  <h2>Automate your AI Governance</h2>
  <ol>
    <li class="fragment fade-in-then-semi-out">
      Create custom context from your contracts, security policies, and product requirements
    </li>
    <li class="fragment fade-in-then-semi-out">
      Start using MCP (Model Context Protocol) tools to enforce custom context in the IDE
    </li>
    <li class="fragment">
      Implement conformance via Policy as Code, and align it to the requirements from your custom context
    </li>
  </ol>
  <aside class="notes">
  </aside>
</section>
<section data-transition="none">
  <h2>Beneficial side-effects</h2>
  <ol>
    <li>
      AI lets us fulfill all of the requirements that we decide are needed during planning features, products, etc. because it
      lets us move more quickly. However, this only happens if we <b>know</b> what the requirements are and <b>remember</b>
      them throughout the project.
    </li>
  <ol>
  <aside class="notes">
  </aside>
</section>
